/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <map>
#include <vector>
#include "../src/lang.hpp"

extern int yylineno;
extern int yylex();
extern int yyparse();
extern FILE *yyin;

map<int, SequenceNode *> eventMap;
map<string, Definition *> defs;

void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}


%}

%union {
  int ival;
  float fval;
  char *sval;
  Note *noteval;
  Tone *toneval;
  Identifier *idval;
  SequenceNode *nodeval;
  vector<SequenceNode *> *nodelistval;
  vector<Identifier *> *idlistval;
}

%token DEFAULT AUTO SEQUENCE

%token <ival>  INT
%token <idval>  IDENTIFIER
%token <noteval>  NOTE
%token <toneval>  TONE_LITERAL
%token <sval>  OPERATOR

// unused
%token <fval>  FLOAT
%token <sval>  STRING

%type  <nodeval> sequence_node instantiation rhs_operand lhs_operand operation 
%type  <nodelistval> node_list
%type  <idlistval> id_list
%type <ival> map_target

%left '+' '-'
%left '*' '/'


%locations
%define parse.error verbose

%start exp

%% 

rhs_operand:
  sequence_node {
    $$ = $1;
  }
  | '(' operation ')' {
    $$ = $2;
  }

;

lhs_operand:
  sequence_node {
    $$ = $1;
  }
  | operation {
    $$ = $1;
  }
  | '(' operation ')' {
    $$ = $2;
  }
;

operation:
  lhs_operand OPERATOR rhs_operand {
    vector<SequenceNode *> *os = new vector<SequenceNode *>();
    os->push_back($1);
    os->push_back($3);
    $$ = (SequenceNode *)new Operation($2, os);
  }
;

id_list: 
  id_list ',' IDENTIFIER {
    $1->push_back($3);
    $$ = $1;
  }
  | IDENTIFIER {
    $$ = new vector<Identifier *>();
    $$->push_back($1);
  }
  | {
    $$ = new vector<Identifier *>();
  }
;

definition: 
  SEQUENCE IDENTIFIER '(' id_list ')' '{' node_list '}' {
    Definition *d = new Definition($2->id, $4, $7);
    defs[$2->id] = d;
  }
;

node_list: 
  node_list ',' sequence_node {
    $1->push_back($3);
    $$ = $1;
  }
  | sequence_node {
    $$ = new vector<SequenceNode *>();
    $$->push_back($1);
  }  
  | {
    $$ = new vector<SequenceNode *>();
  }
;

instantiation:
  IDENTIFIER '(' node_list ')' {
    Definition *d = defs[$1->id];
    Instantiation *i = new Instantiation(d, $3);
    $$ = (SequenceNode *)i;
  }
;

sequence_node:
  IDENTIFIER {
    $$ = (SequenceNode *)$1;
  } 
  | NOTE {
    $$ = (SequenceNode *)$1;
  }
  | TONE_LITERAL {
    $$ = (SequenceNode *)$1;
  }
  | instantiation {
    $$ = (SequenceNode *)$1;
  }  
  | operation {
    $$ = (SequenceNode *)$1;
  }
;

map_target:
  NOTE {
    $$ = $1->key;
  }
  | AUTO {
    $$ = -1;
  }
  | DEFAULT {
    $$ = -2;
  }
;

mapping: 
  map_target ':' sequence_node {
    eventMap[$1] = $3;
    printf(($3->toString()).c_str());
  }
;

exp:   
  exp definition {
  }
| exp mapping {
  }
| definition {
  }
| mapping {
  }
;
%%